<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AI Math Calculator</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico" />
    <style>
      body {
        margin: 0;
        padding: 0;
        font-family: Arial, sans-serif;
        overflow: hidden;
      }
      .toolbar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        background-color: #333;
        padding: 10px;
        color: white;
      }
      .color-tools {
        display: flex;
        gap: 5px;
      }
      .color-tool {
        width: 30px;
        height: 30px;
        border-radius: 50%;
        border: 2px solid white;
        cursor: pointer;
      }
      .active {
        border: 2px solid #ffcc00;
      }
      .eraser {
        background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="white"><path d="M16.24 3.56l4.95 4.94c.78.79.78 2.05 0 2.84L12 20.53a4.008 4.008 0 0 1-5.66 0L2.81 17.1c-.78-.78-.78-2.05 0-2.83l6.59-6.59c.78-.78 2.05-.78 2.83 0l4.01 4.01M3 21h18v2H3v-2z"/></svg>')
          center center no-repeat;
        background-color: #555;
        background-size: 20px;
      }
      .button {
        padding: 8px 16px;
        background-color: #4caf50;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-weight: bold;
        margin-left: 5px;
      }
      .button:hover {
        background-color: #45a049;
      }
      .button:disabled {
        background-color: #cccccc;
        cursor: not-allowed;
        opacity: 0.6;
      }
      .canvas-container {
        position: relative;
        width: 100%;
        height: calc(100vh - 50px);
        background-color: #000;
      }
      canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }
      .clear-button {
        background-color: #f44336;
      }
      .clear-button:hover {
        background-color: #d32f2f;
      }
      .history-buttons {
        display: flex;
        gap: 5px;
      }
      .undo-button {
        background-color: #2196f3;
      }
      .undo-button:hover {
        background-color: #0b7dda;
      }
      .redo-button {
        background-color: #2196f3;
      }
      .redo-button:hover {
        background-color: #0b7dda;
      }
      .result-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.8);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 100;
      }
      .result-box {
        background-color: white;
        padding: 20px;
        border-radius: 8px;
        max-width: 90%;
        max-height: 90%;
        overflow: auto;
      }
      .close-result {
        position: absolute;
        top: 20px;
        right: 20px;
        background-color: white;
        border: none;
        font-size: 24px;
        cursor: pointer;
        border-radius: 50%;
        width: 40px;
        height: 40px;
      }
    </style>
  </head>
  <body>
    <div class="toolbar">
      <div class="color-tools">
        <div
          class="color-tool active"
          style="background-color: white"
          data-color="white"
        ></div>
        <div
          class="color-tool"
          style="background-color: red"
          data-color="red"
        ></div>
        <div
          class="color-tool"
          style="background-color: green"
          data-color="green"
        ></div>
        <div
          class="color-tool"
          style="background-color: blue"
          data-color="blue"
        ></div>
        <div
          class="color-tool"
          style="background-color: yellow"
          data-color="yellow"
        ></div>
        <div class="color-tool eraser" data-color="eraser"></div>
      </div>
      <div style="display: flex; gap: 10px">
        <div class="history-buttons">
          <button class="button undo-button" id="undoButton" disabled>
            Undo
          </button>
          <button class="button redo-button" id="redoButton" disabled>
            Redo
          </button>
        </div>
        <button class="button clear-button" id="clearCanvas">Clear</button>
        <button class="button" id="calculateButton">Calculate</button>
      </div>
    </div>
    <div class="canvas-container">
      <canvas id="drawingCanvas"></canvas>
    </div>

    <div class="result-container" id="resultContainer">
      <button class="close-result" id="closeResult">Ã—</button>
      <div class="result-box" id="resultBox">
        <!-- Solution will be displayed here -->
      </div>
    </div>

    <script>
      document.addEventListener("DOMContentLoaded", function () {
        const canvas = document.getElementById("drawingCanvas");
        const ctx = canvas.getContext("2d");
        const colorTools = document.querySelectorAll(".color-tool");
        const clearButton = document.getElementById("clearCanvas");
        const calculateButton = document.getElementById("calculateButton");
        const resultContainer = document.getElementById("resultContainer");
        const resultBox = document.getElementById("resultBox");
        const closeResult = document.getElementById("closeResult");
        const undoButton = document.getElementById("undoButton");
        const redoButton = document.getElementById("redoButton");

        // History states for undo/redo
        let undoStack = [];
        let redoStack = [];
        const MAX_HISTORY_SIZE = 50; // Limit the history size to prevent memory issues

        // Set canvas size
        function resizeCanvas() {
          canvas.width = canvas.offsetWidth;
          canvas.height = canvas.offsetHeight;

          // Restore current state if it exists
          if (undoStack.length > 0) {
            const currentState = undoStack[undoStack.length - 1];
            ctx.putImageData(currentState, 0, 0);
          } else {
            // Set background to black
            ctx.fillStyle = "black";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Save initial state
            saveState();
          }
        }

        window.addEventListener("resize", resizeCanvas);

        // Drawing variables
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let currentColor = "white";
        let lineWidth = 2;
        let hasDrawnSinceLastSave = false;

        // Color selection
        colorTools.forEach((tool) => {
          tool.addEventListener("click", function () {
            // Remove active class from all tools
            colorTools.forEach((t) => t.classList.remove("active"));
            // Add active class to selected tool
            this.classList.add("active");

            // Set current color or eraser
            if (this.dataset.color === "eraser") {
              currentColor = "black";
              lineWidth = 20; // Larger width for eraser
            } else {
              currentColor = this.dataset.color;
              lineWidth = 2; // Default width for drawing
            }
          });
        });

        // Save the current state to the undo stack
        function saveState() {
          // Limit the stack size
          if (undoStack.length >= MAX_HISTORY_SIZE) {
            undoStack.shift(); // Remove the oldest state
          }

          const currentState = ctx.getImageData(
            0,
            0,
            canvas.width,
            canvas.height
          );
          undoStack.push(currentState);

          // Clear the redo stack when new changes are made
          redoStack = [];

          // Update button states
          updateButtons();

          hasDrawnSinceLastSave = false;
        }

        // Update the enabled/disabled state of undo/redo buttons
        function updateButtons() {
          undoButton.disabled = undoStack.length <= 1; // Keep at least the initial state
          redoButton.disabled = redoStack.length === 0;
        }

        // Drawing functions
        function startDrawing(e) {
          isDrawing = true;
          [lastX, lastY] = getMousePos(canvas, e);
          hasDrawnSinceLastSave = false; // Reset the flag when starting a new stroke
        }

        function draw(e) {
          if (!isDrawing) return;

          const [x, y] = getMousePos(canvas, e);

          ctx.beginPath();
          ctx.moveTo(lastX, lastY);
          ctx.lineTo(x, y);
          ctx.strokeStyle = currentColor;
          ctx.lineWidth = lineWidth;
          ctx.lineCap = "round";
          ctx.stroke();

          [lastX, lastY] = [x, y];

          hasDrawnSinceLastSave = true;
        }

        function stopDrawing() {
          if (isDrawing && hasDrawnSinceLastSave) {
            saveState();
          }
          isDrawing = false;
        }

        // Get mouse position relative to canvas
        function getMousePos(canvas, evt) {
          const rect = canvas.getBoundingClientRect();
          return [
            ((evt.clientX - rect.left) / (rect.right - rect.left)) *
              canvas.width,
            ((evt.clientY - rect.top) / (rect.bottom - rect.top)) *
              canvas.height,
          ];
        }

        // Touch support
        function getTouchPos(canvas, evt) {
          const rect = canvas.getBoundingClientRect();
          return [
            ((evt.touches[0].clientX - rect.left) / (rect.right - rect.left)) *
              canvas.width,
            ((evt.touches[0].clientY - rect.top) / (rect.bottom - rect.top)) *
              canvas.height,
          ];
        }

        function handleStart(e) {
          e.preventDefault();
          isDrawing = true;
          [lastX, lastY] = getTouchPos(canvas, e);
          hasDrawnSinceLastSave = false;
        }

        function handleMove(e) {
          e.preventDefault();
          if (!isDrawing) return;

          const [x, y] = getTouchPos(canvas, e);

          ctx.beginPath();
          ctx.moveTo(lastX, lastY);
          ctx.lineTo(x, y);
          ctx.strokeStyle = currentColor;
          ctx.lineWidth = lineWidth;
          ctx.lineCap = "round";
          ctx.stroke();

          [lastX, lastY] = [x, y];

          hasDrawnSinceLastSave = true;
        }

        // Undo function
        function undo() {
          if (undoStack.length > 1) {
            // Keep at least the initial state
            // Save current state to redo stack
            const currentState = undoStack.pop();
            redoStack.push(currentState);

            // Restore the previous state
            const previousState = undoStack[undoStack.length - 1];
            ctx.putImageData(previousState, 0, 0);

            // Update button states
            updateButtons();
          }
        }

        // Redo function
        function redo() {
          if (redoStack.length > 0) {
            // Get the state to redo
            const redoState = redoStack.pop();

            // Add it to the undo stack
            undoStack.push(redoState);

            // Restore the state
            ctx.putImageData(redoState, 0, 0);

            // Update button states
            updateButtons();
          }
        }

        // Clear canvas function
        function clearCanvas() {
          // Save current state before clearing
          saveState();

          // Clear the canvas
          ctx.fillStyle = "black";
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // Save the cleared state
          saveState();
        }

        // Event listeners
        canvas.addEventListener("mousedown", startDrawing);
        canvas.addEventListener("mousemove", draw);
        canvas.addEventListener("mouseup", stopDrawing);
        canvas.addEventListener("mouseout", stopDrawing);

        // Touch events
        canvas.addEventListener("touchstart", handleStart, { passive: false });
        canvas.addEventListener("touchmove", handleMove, { passive: false });
        canvas.addEventListener("touchend", stopDrawing);

        // Undo/Redo buttons
        undoButton.addEventListener("click", undo);
        redoButton.addEventListener("click", redo);

        // Clear canvas
        clearButton.addEventListener("click", clearCanvas);

        // Calculate button
        // Replace the existing calculateButton event listener with this improved version
        calculateButton.addEventListener("click", function () {
          // Get canvas data
          const imageData = canvas.toDataURL("image/png");

          // Show loading indicator in result box
          resultBox.innerHTML = "<p>Processing your equation...</p>";
          resultContainer.style.display = "flex";

          // Send to backend
          fetch("/calculate", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({ image: imageData }),
          })
            .then((response) => {
              // First check if the response is ok
              if (!response.ok) {
                throw new Error(
                  `Server responded with status: ${response.status}`
                );
              }

              // Get the response text first
              return response.text();
            })
            .then((text) => {
              // Try to parse as JSON
              let data;
              try {
                data = JSON.parse(text);
              } catch (e) {
                console.error("JSON Parse Error:", e);
                console.error("Raw response:", text);
                throw new Error(
                  "Failed to parse server response as JSON. The response might be incomplete or malformed."
                );
              }

              return data;
            })
            .then((data) => {
              // Display result
              if (data.success) {
                resultBox.innerHTML =
                  data.solution ||
                  "Solution processed successfully but was empty.";

                // Initialize MathJax rendering if needed
                if (window.MathJax) {
                  try {
                    MathJax.typeset();
                  } catch (err) {
                    console.error("MathJax error:", err);
                  }
                }
              } else {
                resultBox.innerHTML = `<p>Error: ${
                  data.error || "Unknown error occurred"
                }</p>`;
              }
            })
            .catch((error) => {
              console.error("Fetch error:", error);
              resultBox.innerHTML = `<p>Error: ${error.message}</p>
                              <p>Please try again or try with a simpler equation.</p>`;
            });
        });

        // Close result
        closeResult.addEventListener("click", function () {
          resultContainer.style.display = "none";
        });

        // Add keyboard shortcuts
        document.addEventListener("keydown", function (e) {
          // Ctrl+Z for Undo
          if (e.ctrlKey && e.key === "z" && !undoButton.disabled) {
            e.preventDefault();
            undo();
          }

          // Ctrl+Y for Redo
          if (e.ctrlKey && e.key === "y" && !redoButton.disabled) {
            e.preventDefault();
            redo();
          }

          // Ctrl+Shift+Z for Redo (alternative)
          if (
            e.ctrlKey &&
            e.shiftKey &&
            e.key === "Z" &&
            !redoButton.disabled
          ) {
            e.preventDefault();
            redo();
          }
        });

        // Initialize the canvas
        resizeCanvas();
      });
    </script>

    <!-- Add MathJax for rendering mathematical expressions -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-mml-chtml.js"></script>
  </body>
</html>
